(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{338:function(t,a,s){"use strict";s.r(a);var n=s(1),v=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"javascript之垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript之垃圾回收机制","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaScript之垃圾回收机制")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("本文主要摘自《JavaScript高级程序设计》")]),t._v(" "),s("p",[t._v("一般程序的内存管理都是：")]),t._v(" "),s("ol",[s("li",[t._v("分配内存（如声明变量，函数）")]),t._v(" "),s("li",[t._v("使用内存（如使用变量，函数）")]),t._v(" "),s("li",[t._v("释放内存（使用完毕后垃圾自动回收，释放内存）")])]),t._v(" "),s("h2",{attrs:{id:"标记清除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记清除","aria-hidden":"true"}},[t._v("#")]),t._v(" 标记清除")]),t._v(" "),s("p",[t._v("在"),s("code",[t._v("JavaScript")]),t._v("中最常用的垃圾回收机制就是标记清楚,它的原理是当变量进入环境时，此时将这个变量标记为进入环境，当变量离开环境的时候，则将其标记为离开环境，可以通过翻转某一个位来标记一个变量何时进入了环境。但标记不是重点，重点是标记了之后怎么来将其处理。垃圾收集器会在运行的时候给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量应用的标记，在此之后再把加上标记的变量都将被视为准备删除的变量。最后，垃圾收集器完成内存的清除工作，销毁那些带标记的值并收回它们所占用的内存空间")]),t._v(" "),s("h2",{attrs:{id:"引用计数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用计数","aria-hidden":"true"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),s("p",[t._v("引用计数的策略跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，没有办法再访问这个这个值，就将其占用的内存空间收回来，下次再运行垃圾收集器的时候，就会释放哪些引用次数为0的值所占用的内存了。")]),t._v(" "),s("p",[t._v("但存在的一个问题是，如果有循环引用，即"),s("code",[t._v("A")]),t._v("有个指针指向"),s("code",[t._v("B")]),t._v("，"),s("code",[t._v("B")]),t._v("也有一个指针指向"),s("code",[t._v("A")]),t._v("，在采用标记清除策略的实现中，这将是没有问题的，但是在引用计数中就会出现问题，因为"),s("code",[t._v("A")]),t._v("和"),s("code",[t._v("B")]),t._v("的计数永远都不会为"),s("code",[t._v("0")]),t._v("，这样会造成内存泄漏。")]),t._v(" "),s("p",[t._v("例如：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{attrs:{class:"token function"}},[t._v("fun")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{attrs:{class:"token constant"}},[t._v("A")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{attrs:{class:"token constant"}},[t._v("B")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{attrs:{class:"token constant"}},[t._v("A")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token constant"}},[t._v("B")]),t._v("\n    "),s("span",{attrs:{class:"token constant"}},[t._v("B")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token constant"}},[t._v("A")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("当如果采用引用计数来回收，那么"),s("code",[t._v("A")]),t._v("和"),s("code",[t._v("B")]),t._v("将不会被回收，因为它们相互引用，引用次数不会为"),s("code",[t._v("0")]),t._v("，这样可能会造成内存泄漏，这个问题在"),s("code",[t._v("IE")]),t._v("中会遇到,在"),s("code",[t._v("IE")]),t._v("中虽然"),s("code",[t._v("JavaScript")]),t._v("对象通过标记清除的方式进行垃圾回收，但"),s("code",[t._v("BOM")]),t._v("与"),s("code",[t._v("DOM")]),t._v("对象却是通过引用计数回收垃圾的。")]),t._v(" "),s("p",[t._v("如果"),s("code",[t._v("DOM")]),t._v("元素和原生"),s("code",[t._v("JS")]),t._v("对象之间创建了循环引用，那就带来内存泄露的问题")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" dom "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("getElementById")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token string"}},[t._v("'div'")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\ndom"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj"),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nobj"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dom "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" dom"),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("上面这个例子在DOM元素和JavaScript对象之间会创建循环引用的关系，这时在"),s("code",[t._v("IE")]),t._v("中它们将不会被回收，这时我们可以这样:")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("dom"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("null")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nobj"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dom "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("null")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"性能问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 性能问题")]),t._v(" "),s("p",[t._v("垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。"),s("code",[t._v("IE6")]),t._v("的垃圾回收是根据内存分配量运行的，当环境中存在"),s("code",[t._v("256")]),t._v("个变量、"),s("code",[t._v("4096")]),t._v("个对象、"),s("code",[t._v("64k")]),t._v("的字符串任意一种情况的时候就会触发垃圾回收器工作。这种实现方式的问题在于，如果一个脚本汇总包含那么多变量，那么该脚本很可能会在其他生命周期中一直保有那么多的变量。这样会使垃圾收集器频繁的工作。")]),t._v(" "),s("p",[t._v("微软在"),s("code",[t._v("IE7")]),t._v("中做了调整，触发条件不再是固定的，而是动态修改的，初始值和"),s("code",[t._v("IE6")]),t._v("相同，如果垃圾回收器回收的内存分配量低于程序占用内存的"),s("code",[t._v("15%")]),t._v("，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于"),s("code",[t._v("85%")]),t._v("，说明大部分内存早就该清理了，这时候把触发条件置回，这样极大的提升了"),s("code",[t._v("IE")]),t._v("在运行包含大量的"),s("code",[t._v("JavaScript")]),t._v("的页面时的性能。")])])}],!1,null,null,null);v.options.__file="trash-recycling.md";a.default=v.exports}}]);