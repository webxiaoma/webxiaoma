---
sidebarDepth: 1
meta:
  - name: keywords
    content: webpack, 懒加载, 按需加载，webpack懒加载，webpack按需加载，import()
  - name: description
    content: 本文主要讲述使用webpack实现懒加载，（也可以称为按需加载）。
---

# 提取公共模块

[GitHub 仓库练习](https://github.com/webxiaoma/webpack-demos/tree/master/webpack4/%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E6%A8%A1%E5%9D%97)

---

在 <Badge>webpack v3.0+</Badge>中我们提取公共代码使用的是 [CommonsCHunkPlugin 插件](https://webpack.docschina.org/plugins/commons-chunk-plugin/), 而在 <Badge>webpack v4.0+</Badge>中我们使用[SplitChunksPlugin 插件](https://www.webpackjs.com/plugins/split-chunks-plugin/)

我们在开发项目时经常会用到插件，比如`vue`，`react`等等一些其他插件，这些插件我们可以单独打包出来放到一个文件中，这样减少我们的代码的冗余，来提高我们的加载速度。


## 配置

这里我们来简单介绍在`webpack4` 中使用`SplitChunksPlugin`插件来实现提取公共代码。`SplitChunksPlugin`插件在`webpack4` 中已经内置了，我们只需要在配置文件中的`optimization.splitChunks`字段中去配置就可以，常见的配置项如下：

```js
module.exports = {
    // 其他配置..
    optimization:{
        splitChunks:{
             /*
                all  异步和同步都可以共享
                async 表示对动态（异步）导入的模块进行分离。
                initial 表示对初始化值进行分离优化。
             */
            chunks:'all',//  async、 initial 、 all
            name:'jquery', //打包后的名字
            minSize:2000, //(默认是30000)：形成一个新代码块最小的体积
            //（默认是1）：在分割之前，这个代码块最小应该被引用的次数
            //（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）
            minChunks:1, 
            maxInitialRequests:3, //（默认是3）：一个入口最大的并行请求数
            maxAsyncRequests:5, //（默认是5）：按需加载时候最大的并行请求数。
            //  此选项允许您指定用于生成名称的分隔符 默认以~分割
            automaticNameDelimiter: '~',

            // 下面是缓存组的配置
            //缓存组会继承splitChunks的配置，
            //但是test、priorty和reuseExistingChunk只能用于配置缓存组。
            //可以通过optimization.splitChunks.cacheGroups.default: false禁用default缓存组
            cacheGroups: { 
                default: { // 默认缓存组的配置
                    minChunks: 2,
                    //定义缓存组的优先级 更高优先级的缓存组可以优先打包所选择的模块）（默认自定义缓存组优先级为0）
                    priority: -20, 
                    //选项允许复用已经存在的代码块，而不是新建一个新的，需要在精确匹配到对应模块时候才会生效。
                    reuseExistingChunk: true,
                },
                vendors: {
                    //选项用于控制哪些模块被这个缓存组匹配到 默认所有模块
                    // 值得类型RegExp、String和Function
                    test: /[\\/]node_modules[\\/]/, // 这里选的是node_modules中的模块
                    priority: -10 //定义缓存组的优先级
                }
            }
        }
    },
}
```

另外当我们设置`optimization.splitChunks.chunks: "all"`时，`webpack`是有默认的方式，webpack根据下述条件自动进行代码块分割：

- 新代码块可以被共享引用，OR这些模块都是来自node_modules文件夹里面
- 新代码块大于30kb（min+gziped之前的体积）
- 按需加载的代码块，最大数量应该小于或者等于5
- 初始加载的代码块，最大数量应该小于或等于3

[SplitChunksPlugin 配置的中文](https://github.com/yesvods/Blog/issues/15)


## 使用

根据以上的配置我们可以来尝试一下，比如我们将使用`npm` 下载的`jquery` 打包出来。我们的配置为

```js
//index.js
import $ from 'jquery'
let fun = a =>console.log($('.a'))
```

```js
// webpack.config.js
module.exports = {
  output: {
    filename: 'build.js',
    // 为生成的chunk其名字
    chunkFilename:'[name].buildChunk.js',
    path: path.resolve(__dirname, './dist')
  },   
  optimization:{
    splitChunks:{
        chunks:'all',//  async、 initial 、 all
        name:'jquery', //打包后的名字
    }
  },
}
```
现在`webpack`执行时会将`jq`打包到一个文件中。

另外如果我们这样设置, 只会打包按需加载的大于10字节的模块

```js
module.exports = {
   optimization:{
        splitChunks:{
            chunks:'async', // 会将按需加载的模块打包到单独文件中
            minSize:10,  //打包10字节以上的模块 默认30000
        }
   },
}
```

配置缓存组我们可以使用下面配置：

```js
module.exports = {
  optimization:{
    splitChunks:{
    chunks:'all',
    minSize:100,  // 默认30000
    //  maxSize:160,
    automaticNameDelimiter: '-', // 将连接符~ 换成 -
    cacheGroups:{
        default: { // 默认缓存组的配置
            name:'commons',
            minChunks: 2,
            //定义缓存组的优先级 更高优先级的缓存组可以优先打包所选择的模块）（默认自定义缓存组优先级为0）
            priority: -20, 
            //选项允许复用已经存在的代码块，而不是新建一个新的，需要在精确匹配到对应模块时候才会生效。
            reuseExistingChunk: true,
        },
        query: {
            //选项用于控制哪些模块被这个缓存组匹配到 默认所有模块
            // 值得类型RegExp、String和Function
            test: /[\\/]node_modules[\\/]/, // 这里选的是node_modules中的模块
            priority: -10 //定义缓存组的优先级
        }
     }
   }
  }
}
```

该配置将`node_modules`目录的公共代码放到了一个chunk中并打包出来，将其他目录中非懒加载的模块合并到一起打包出来，懒加载的合并到了一起并输出。













